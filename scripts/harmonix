#!/usr/bin/env bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() { echo -e "${BLUE}â„¹ ${NC} $1"; }
print_success() { echo -e "${GREEN}âœ“${NC} $1"; }
print_error() { echo -e "${RED}âœ—${NC} $1"; }
print_warning() { echo -e "${YELLOW}âš ${NC} $1"; }

# Function to show general usage
usage() {
    cat << EOF
$(print_info "Harmonix - Nix Project Initializer")

$(print_success "USAGE:")
  $(basename "$0") <language> [OPTIONS]
  $(basename "$0") <language> --help    # Show language-specific help

$(print_success "LANGUAGES:")
  python      Python with uv package manager
  cpp         C++ with modern toolchain
  cpp-python  C++ with Python bindings via pybind11
  latex       LaTeX document authoring

$(print_success "COMMON OPTIONS:")
  --name NAME       Project name (default: current directory)
  --help, -h        Show help (general or language-specific)

$(print_success "EXAMPLES:")
  $(basename "$0") python --name ml-project --py 3.12
  $(basename "$0") cpp --cpp 23 --llvm 21 --test-framework catch2
  $(basename "$0") cpp --package-manager vcpkg --analysis --docs
  $(basename "$0") latex --pandoc --scheme full

$(print_success "FOR LANGUAGE-SPECIFIC OPTIONS:")
  $(basename "$0") python --help
  $(basename "$0") cpp --help
  $(basename "$0") latex --help

$(print_info "Each project includes:")
  â€¢ Nix flake for reproducible environment
  â€¢ Direnv for automatic shell activation
  â€¢ Neovim LSP/DAP configuration
  â€¢ Language-specific starter files
  â€¢ Comprehensive .gitignore

EOF
    exit 0
}

# Language-specific help functions
python_help() {
    cat << EOF
$(print_info "Python Project Initializer")

$(print_success "USAGE:")
  $(basename "$0") python [OPTIONS]

$(print_success "OPTIONS:")
  --name NAME           Project name (default: current directory)
  --py VER              Python version: 3.10, 3.11, 3.12, 3.13, 3.14 (default: 3.11)
  --help                Show this help

$(print_success "WHAT YOU GET:")
  â€¢ Python environment (configurable version)
  â€¢ Virtual environment with uv package manager
  â€¢ LSP: basedpyright and ruff (configured for venv)
  â€¢ Formatter: black
  â€¢ Jupyter/Molten support for notebooks in neovim
  â€¢ requirements.txt for dependencies
  â€¢ .nvim.lua with venv-aware configuration

$(print_success "PACKAGE MANAGEMENT:")
  $(print_info "Nix provides:")
    - Python interpreter, uv, development tools
    - LSP servers, formatters, debuggers
    - System dependencies for packages

  $(print_info "uv manages (via requirements.txt):")
    - Project-specific Python packages
    - Version pinning with pip freeze

$(print_success "WORKFLOW:")
  1. Create project:       $(basename "$0") python --name myapp
  2. Enter directory:      cd myapp
  3. Add dependencies:     echo "pandas>=2.0" >> requirements.txt
  4. Install packages:     uv pip install -r requirements.txt
  5. Open in neovim:       nvim myapp.py
  6. Start Jupyter kernel: :MoltenInit python3

$(print_success "ADDING SYSTEM DEPENDENCIES:")
  Edit flake.nix to add packages needed by Python libraries:
    extraPackages = with pkgs; [
      postgresql  # for psycopg2
      libxml2     # for lxml
      gdal        # for geodjango
    ];

EOF
    exit 0
}

cpp_help() {
    cat << EOF
$(print_info "C++ Project Initializer")

$(print_success "USAGE:")
  $(basename "$0") cpp [OPTIONS]

$(print_success "OPTIONS:")
  --name NAME           Project name (default: current directory)
  --cpp STD             C++ standard: 11, 14, 17, 20, 23 (default: 20)
  --llvm V              LLVM version: 18, 19, 20, 21 (default: 20)
  --package-manager PM  Package manager: conan, vcpkg, cpm, none (default: conan)
  --test-framework TF   Test framework: gtest, catch2, doctest, boost, none (default: gtest)
  --bazel               Enable Bazel support
  --docs                Enable documentation tools (doxygen, graphviz)
  --analysis            Enable analysis tools (cppcheck, valgrind, etc.)
  --help                Show this help

$(print_success "WHAT YOU GET:")
  â€¢ Complete LLVM toolchain (clang, clang-tools, lld, lldb)
  â€¢ Build tools: CMake, Ninja, Conan (default), Google Test (default)
  â€¢ LSP: clangd with compile_commands.json support
  â€¢ Formatter: clang-format
  â€¢ CMakeLists.txt with configurable C++ standard
  â€¢ src/main.cpp starter file
  â€¢ .nvim.lua with project-aware configuration

$(print_success "WORKFLOW:")
  1. Create project:    $(basename "$0") cpp --name myapp
  2. Enter directory:   cd myapp
  3. Install deps:      conan install . --profile ./.conan2/release --build=missing
  4. Configure build:   cmake --preset conan-release
  5. Build project:     cmake --build --preset conan-release

  # Without Conan (if no dependencies):
  1. Configure:         cmake -S . -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
  2. Build:             cmake --build build

$(print_success "COMPILE COMMANDS:")
  The .nvim.lua automatically links compile_commands.json from build/
  to project root for clangd to find it.

EOF
    exit 0
}

cpp_python_help() {
    cat << EOF
$(print_info "C++ + Python Hybrid Project Initializer")

$(print_success "USAGE:")
  $(basename "$0") cpp-python [OPTIONS]

$(print_success "OPTIONS:")
  --name NAME           Project name (default: current directory)
  --cpp STD             C++ standard: 11, 14, 17, 20, 23 (default: 20)
  --llvm V              LLVM version: 18, 19, 20, 21 (default: 20)
  --py VER              Python version: 3.10, 3.11, 3.12, 3.13, 3.14 (default: 3.11)
  --help                Show this help

$(print_success "WHAT YOU GET:")
  â€¢ Complete LLVM toolchain for C++
  â€¢ Python environment with uv package manager
  â€¢ pybind11 for C++/Python bindings
  â€¢ Example C++ module with Python bindings
  â€¢ Python script using the C++ module
  â€¢ CMakeLists.txt configured for Python extensions
  â€¢ Tests for both C++ and Python code

$(print_success "PROJECT STRUCTURE:")
  src/
    â”œâ”€â”€ bindings.cpp    # pybind11 module definition
    â”œâ”€â”€ math_ops.cpp    # C++ implementation
    â””â”€â”€ math_ops.h      # C++ header
  python/
    â””â”€â”€ example.py      # Python usage example
  tests/
    â”œâ”€â”€ test_cpp.cpp    # C++ unit tests
    â””â”€â”€ test_python.py  # Python unit tests
  CMakeLists.txt        # Build configuration
  setup.py              # Python package setup

$(print_success "WORKFLOW:")
  1. Create project:    $(basename "$0") cpp-python --name mylib
  2. Enter directory:   cd mylib
  3. Configure:         cmake -S . -B build -DPYTHON_EXECUTABLE=\$(which python)
  4. Build:             cmake --build build
  5. Install:           pip install -e .
  6. Test C++:          ./build/tests/test_cpp
  7. Test Python:       pytest tests/

$(print_success "FEATURES:")
  â€¢ Automatic Python venv creation with uv
  â€¢ Example demonstrates passing arrays between C++ and Python
  â€¢ Includes exception handling across language boundary
  â€¢ CMake automatically finds Python and pybind11
  â€¢ Tests demonstrate both C++ and Python usage

EOF
    exit 0
}

latex_help() {
    cat << EOF
$(print_info "LaTeX Project Initializer")

$(print_success "USAGE:")
  $(basename "$0") latex [OPTIONS]

$(print_success "OPTIONS:")
  --name NAME       Project name (default: current directory)
  --scheme SCHEME   TeX scheme: basic, small, medium, full (default: medium)
  --pandoc          Enable Pandoc for markdown conversion
  --biber           Enable Biber for bibliography
  --graphics        Enable graphics tools (inkscape, gnuplot)
  --python          Enable Python integration (pythontex)
  --help            Show this help

$(print_success "WHAT YOU GET:")
  â€¢ TeXLive distribution (size based on scheme)
  â€¢ LSP: texlab for completion and diagnostics
  â€¢ Build tool: latexmk for continuous compilation
  â€¢ main.tex starter document
  â€¢ .latexmkrc configuration
  â€¢ Directories: figures/, sections/

$(print_success "SCHEMES:")
  basic   - Minimal TeX installation
  small   - Basic document classes
  medium  - Most packages, recommended (default)
  full    - Everything including obscure packages

$(print_success "OPTIONAL FEATURES:")
  $(print_info "Pandoc (--pandoc):")
    - Convert between markdown, LaTeX, Word, etc.
    - Pandoc filters for custom processing

  $(print_info "Graphics (--graphics):")
    - Inkscape for SVG editing
    - Gnuplot for data plots
    - ImageMagick for conversions

$(print_success "WORKFLOW:")
  1. Create project:      $(basename "$0") latex --name paper --pandoc
  2. Enter directory:     cd paper
  3. Continuous build:    latexmk -pvc -pdf main.tex
  4. Open in neovim:      nvim main.tex
  5. Convert markdown:    pandoc input.md -o output.tex

$(print_success "LATEXMK:")
  The .latexmkrc is configured for:
    - PDF output with synctex
    - Automatic viewer refresh
    - Comprehensive cleanup

EOF
    exit 0
}

# Parse arguments
PROJECT_TYPE=""
PROJECT_NAME="$(basename "$PWD")"
# Molten/Jupyter now always included for Python
SCHEME="medium"
PANDOC=false
BIBER=false
GRAPHICS=false
PYTHON_TEX=false
# Version selections (keep Python default in sync with packages.nix!)
PYTHON_VERSION="3.11"
CPP_STANDARD="20"
LLVM_VERSION="20"
# C++ options
PACKAGE_MANAGER="conan"
TEST_FRAMEWORK="gtest"
WITH_BAZEL=false
WITH_DOCS=false
WITH_ANALYSIS=false

# Check if no arguments provided or just --help
if [[ $# -eq 0 ]] || [[ $1 == "--help" ]] || [[ $1 == "-h" ]]; then
    usage
fi

# Store the first argument as potential language
FIRST_ARG="$1"

# Check for language-specific help
if [[ $1 == "python" || $1 == "cpp" || $1 == "cpp-python" || $1 == "latex" ]]; then
    if [[ $# -eq 2 ]] && [[ $2 == "--help" || $2 == "-h" ]]; then
        case $1 in
            python)
                python_help
                ;;
            cpp)
                cpp_help
                ;;
            cpp-python)
                cpp_python_help
                ;;
            latex)
                latex_help
                ;;
        esac
    fi
fi

while [[ $# -gt 0 ]]; do
    case $1 in
        python|cpp|cpp-python|latex)
            PROJECT_TYPE="$1"
            shift
            ;;
        --name)
            PROJECT_NAME="$2"
            shift 2
            ;;
        --scheme)
            SCHEME="$2"
            shift 2
            ;;
        --pandoc)
            PANDOC=true
            shift
            ;;
        --biber)
            BIBER=true
            shift
            ;;
        --graphics)
            GRAPHICS=true
            shift
            ;;
        --python)
            PYTHON_TEX=true
            shift
            ;;
        --python-version|--py)
            PYTHON_VERSION="$2"
            shift 2
            ;;
        --cpp)
            CPP_STANDARD="$2"
            shift 2
            ;;
        --llvm)
            LLVM_VERSION="$2"
            shift 2
            ;;
        --package-manager)
            PACKAGE_MANAGER="$2"
            shift 2
            ;;
        --test-framework)
            TEST_FRAMEWORK="$2"
            shift 2
            ;;
        --bazel)
            WITH_BAZEL=true
            shift
            ;;
        --docs)
            WITH_DOCS=true
            shift
            ;;
        --analysis)
            WITH_ANALYSIS=true
            shift
            ;;
        --help|-h)
            if [[ -n "$PROJECT_TYPE" ]]; then
                case $PROJECT_TYPE in
                    python) python_help ;;
                    cpp) cpp_help ;;
                    latex) latex_help ;;
                esac
            else
                usage
            fi
            ;;
        *)
            print_error "Unknown option: $1"
            usage
            ;;
    esac
done

# Check if project type was specified
if [[ -z "$PROJECT_TYPE" ]]; then
    print_error "No project type specified"
    usage
fi

# Create project directory if name was provided and we're not already in it
if [[ "$PROJECT_NAME" != "$(basename "$PWD")" ]]; then
    if [[ -d "$PROJECT_NAME" ]]; then
        print_warning "Directory '$PROJECT_NAME' already exists"
        read -p "Continue in existing directory? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_info "Cancelled"
            exit 1
        fi
    else
        print_info "Creating directory: $PROJECT_NAME"
        mkdir -p "$PROJECT_NAME"
    fi
    cd "$PROJECT_NAME"
fi

# Check if files already exist
if [[ -f "flake.nix" ]]; then
    print_warning "flake.nix already exists in $(basename "$PWD")"
    read -p "Overwrite? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_info "Cancelled"
        exit 1
    fi
fi

# Create flake.nix based on project type
print_info "Creating flake.nix for $PROJECT_TYPE project: $PROJECT_NAME"

case $PROJECT_TYPE in
    python)
        cat > flake.nix << EOF
{
  description = "$PROJECT_NAME - Python project";

  inputs = {
    # Note: system-flakes includes all inputs for the full system config.
    # First-time use will download these dependencies, but they're cached afterward.
    system-flakes.url = "github:dlond/system-flakes";
    nixpkgs.follows = "system-flakes/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, system-flakes, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.\${system};
      in
      {
        devShells.default = system-flakes.devShellTemplates.python {
          inherit pkgs;
          projectName = "$PROJECT_NAME";
          pythonVersion = "$PYTHON_VERSION";

          # Add project-specific packages here
          extraPackages = with pkgs; [
            # postgresql
            # redis
          ];
        };
      });
}
EOF
        ;;


    cpp)
        cat > flake.nix << EOF
{
  description = "$PROJECT_NAME - C++ project";

  inputs = {
    # Note: system-flakes includes all inputs for the full system config.
    # First-time use will download these dependencies, but they're cached afterward.
    system-flakes.url = "github:dlond/system-flakes";
    nixpkgs.follows = "system-flakes/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, system-flakes, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.\${system};
      in
      {
        devShells.default = system-flakes.devShellTemplates.cpp {
          inherit pkgs;
          projectName = "$PROJECT_NAME";
          cppStandard = "$CPP_STANDARD";
          llvmVersion = "$LLVM_VERSION";
          packageManager = "$PACKAGE_MANAGER";
          testFramework = "$TEST_FRAMEWORK";
          withBazel = $WITH_BAZEL;
          withDocs = $WITH_DOCS;
          withAnalysis = $WITH_ANALYSIS;

          # Add project-specific packages here
          extraPackages = with pkgs; [
            # boost
            # opencv
          ];
        };
      });
}
EOF
        ;;

    latex)
        cat > flake.nix << EOF
{
  description = "$PROJECT_NAME - LaTeX document";

  inputs = {
    # Note: system-flakes includes all inputs for the full system config.
    # First-time use will download these dependencies, but they're cached afterward.
    system-flakes.url = "github:dlond/system-flakes";
    nixpkgs.follows = "system-flakes/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, system-flakes, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.\${system};
      in
      {
        devShells.default = system-flakes.devShellTemplates.latex {
          inherit pkgs;
          projectName = "$PROJECT_NAME";
          scheme = "$SCHEME";
          withPandoc = $PANDOC;
          withBiber = $BIBER;
          withGraphics = $GRAPHICS;
          withPython = $PYTHON_TEX;

          # Add project-specific packages here
          extraPackages = with pkgs; [
            # aspell
            # aspellDicts.en
          ];
        };
      });
}
EOF
        ;;
    cpp-python)
        cat > flake.nix << EOF
{
  description = "$PROJECT_NAME - C++ + Python hybrid project";

  inputs = {
    # Note: system-flakes includes all inputs for the full system config.
    # First-time use will download these dependencies, but they're cached afterward.
    system-flakes.url = "github:dlond/system-flakes";
    nixpkgs.follows = "system-flakes/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, system-flakes, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.\${system};
      in
      {
        devShells.default = system-flakes.devShellTemplates."cpp-python" {
          inherit pkgs;
          projectName = "$PROJECT_NAME";
          cppStandard = "$CPP_STANDARD";
          llvmVersion = "$LLVM_VERSION";
          pythonVersion = "$PYTHON_VERSION";

          # Add project-specific packages here
          extraPackages = with pkgs; [
            # numpy
            # scipy
          ];
        };
      });
}
EOF
        ;;
esac

print_success "Created flake.nix"

# Create .envrc
print_info "Creating .envrc"
if [[ "$PROJECT_TYPE" == "python" ]] || [[ "$PROJECT_TYPE" == "cpp-python" ]]; then
    cat > .envrc << 'EOF'
use flake
layout python

# Project-specific environment setup
# Add any additional environment variables or setup here
EOF
else
    cat > .envrc << 'EOF'
use flake

# Project-specific environment setup
# Add any additional environment variables or setup here
EOF
fi

print_success "Created .envrc"

# Create .gitignore if it doesn't exist
if [[ ! -f ".gitignore" ]]; then
    print_info "Creating .gitignore"
    cat > .gitignore << EOF
# Nix
result
result-*

# Direnv
.direnv/

# Editor
.nvim.lua
*.swp
*~

EOF

    # Add language-specific ignores
    case $PROJECT_TYPE in
        python)
            cat >> .gitignore << EOF
# Python
.venv/
venv/
*.pyc
__pycache__/
.pytest_cache/
*.egg-info/
dist/
build/
.ipynb_checkpoints/
EOF
            ;;
        cpp)
            cat >> .gitignore << EOF
# C++
build/
compile_commands.json
*.o
*.a
*.so
*.dylib
EOF
            ;;
        latex)
            cat >> .gitignore << EOF
# LaTeX
*.aux
*.log
*.out
*.pdf
*.synctex.gz
*.bbl
*.bcf
*.blg
*.fdb_latexmk
*.fls
*.run.xml
*.toc
EOF
            ;;
    esac

    print_success "Created .gitignore"
fi

# Create project-specific files
case $PROJECT_TYPE in
    python)
        if [[ ! -f "requirements.txt" ]]; then
            touch requirements.txt
            print_success "Created empty requirements.txt"
        fi
        if [[ ! -f "README.md" ]]; then
            cat > README.md << EOF
# $PROJECT_NAME

A Python project generated with harmonix.

## Setup

1. Create and activate virtual environment:
   \`\`\`bash
   uv venv
   source .venv/bin/activate
   \`\`\`

2. Install dependencies:
   \`\`\`bash
   uv pip install -r requirements.txt
   \`\`\`

3. Run the module:
   \`\`\`bash
   python ${PROJECT_NAME//-/_}.py
   \`\`\`

4. Run tests:
   \`\`\`bash
   pytest
   \`\`\`
EOF
            print_success "Created README.md"
        fi

        # Create main Python module
        if [[ ! -f "${PROJECT_NAME//-/_}.py" ]]; then
            cat > "${PROJECT_NAME//-/_}.py" << 'EOF'
"""
Main module for PROJECT_NAME.

This module provides basic functionality and serves as an entry point.
"""

import sys
from typing import List, Optional


def greet(name: str = "World") -> str:
    """
    Generate a greeting message.

    Args:
        name: The name to greet

    Returns:
        A greeting message
    """
    return f"Hello, {name}!"


def add_numbers(a: float, b: float) -> float:
    """
    Add two numbers together.

    Args:
        a: First number
        b: Second number

    Returns:
        Sum of a and b
    """
    return a + b


def fibonacci(n: int) -> List[int]:
    """
    Generate Fibonacci sequence up to n numbers.

    Args:
        n: Number of Fibonacci numbers to generate

    Returns:
        List of Fibonacci numbers

    Raises:
        ValueError: If n is negative
    """
    if n < 0:
        raise ValueError("n must be non-negative")

    if n == 0:
        return []
    elif n == 1:
        return [0]
    elif n == 2:
        return [0, 1]

    fib = [0, 1]
    for i in range(2, n):
        fib.append(fib[i-1] + fib[i-2])

    return fib


def main() -> None:
    """Main function demonstrating module functionality."""
    print(greet("Python Developer"))
    print(f"2 + 3 = {add_numbers(2, 3)}")

    fib_numbers = fibonacci(10)
    print(f"First 10 Fibonacci numbers: {fib_numbers}")


if __name__ == "__main__":
    main()
EOF
            # Replace PROJECT_NAME placeholder
            sed -i "s/PROJECT_NAME/$PROJECT_NAME/g" "${PROJECT_NAME//-/_}.py"
            print_success "Created ${PROJECT_NAME//-/_}.py"
        fi

        # Create test directory and files
        mkdir -p tests

        if [[ ! -f "tests/__init__.py" ]]; then
            touch "tests/__init__.py"
            print_success "Created tests/__init__.py"
        fi

        if [[ ! -f "tests/test_${PROJECT_NAME//-/_}.py" ]]; then
            cat > "tests/test_${PROJECT_NAME//-/_}.py" << 'EOF'
"""
Tests for PROJECT_NAME module.

Run with: pytest
"""

import pytest
import sys
from pathlib import Path

# Add the project root to the path so we can import our module
sys.path.insert(0, str(Path(__file__).parent.parent))

from MODULE_NAME import greet, add_numbers, fibonacci


class TestGreet:
    """Test cases for the greet function."""

    def test_greet_default(self):
        """Test greeting with default name."""
        assert greet() == "Hello, World!"

    def test_greet_with_name(self):
        """Test greeting with specific name."""
        assert greet("Alice") == "Hello, Alice!"

    def test_greet_empty_string(self):
        """Test greeting with empty string."""
        assert greet("") == "Hello, !"


class TestAddNumbers:
    """Test cases for the add_numbers function."""

    def test_add_positive_numbers(self):
        """Test adding positive numbers."""
        assert add_numbers(2, 3) == 5
        assert add_numbers(10, 20) == 30

    def test_add_negative_numbers(self):
        """Test adding negative numbers."""
        assert add_numbers(-1, -2) == -3
        assert add_numbers(-5, 3) == -2

    def test_add_floats(self):
        """Test adding floating point numbers."""
        result = add_numbers(1.5, 2.5)
        assert abs(result - 4.0) < 1e-10

    def test_add_zero(self):
        """Test adding zero."""
        assert add_numbers(5, 0) == 5
        assert add_numbers(0, 0) == 0


class TestFibonacci:
    """Test cases for the fibonacci function."""

    def test_fibonacci_zero(self):
        """Test Fibonacci with n=0."""
        assert fibonacci(0) == []

    def test_fibonacci_one(self):
        """Test Fibonacci with n=1."""
        assert fibonacci(1) == [0]

    def test_fibonacci_two(self):
        """Test Fibonacci with n=2."""
        assert fibonacci(2) == [0, 1]

    def test_fibonacci_ten(self):
        """Test Fibonacci with n=10."""
        expected = [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]
        assert fibonacci(10) == expected

    def test_fibonacci_negative(self):
        """Test Fibonacci with negative n."""
        with pytest.raises(ValueError, match="n must be non-negative"):
            fibonacci(-1)


class TestIntegration:
    """Integration tests combining multiple functions."""

    def test_fibonacci_and_add(self):
        """Test using fibonacci result with add_numbers."""
        fib = fibonacci(5)  # [0, 1, 1, 2, 3]
        assert len(fib) == 5
        assert add_numbers(fib[0], fib[-1]) == 3  # 0 + 3


# Pytest fixtures example
@pytest.fixture
def sample_numbers():
    """Fixture providing sample numbers for testing."""
    return [1, 2, 3, 4, 5]


def test_with_fixture(sample_numbers):
    """Test using a pytest fixture."""
    total = sum(sample_numbers)
    assert total == 15


# Parametrized test example
@pytest.mark.parametrize("name,expected", [
    ("Alice", "Hello, Alice!"),
    ("Bob", "Hello, Bob!"),
    ("Charlie", "Hello, Charlie!"),
])
def test_greet_parametrized(name, expected):
    """Test greet function with multiple parameters."""
    assert greet(name) == expected


if __name__ == "__main__":
    # Allow running tests directly with: python test_module.py
    pytest.main([__file__, "-v"])
EOF
            # Replace placeholders
            sed -i "s/PROJECT_NAME/$PROJECT_NAME/g" "tests/test_${PROJECT_NAME//-/_}.py"
            sed -i "s/MODULE_NAME/${PROJECT_NAME//-/_}/g" "tests/test_${PROJECT_NAME//-/_}.py"
            print_success "Created tests/test_${PROJECT_NAME//-/_}.py"
        fi

        # Update requirements.txt to include pytest
        if [[ ! -s "requirements.txt" ]]; then
            cat > requirements.txt << 'EOF'
pytest>=7.0.0
# Add your project dependencies here
# Example: numpy>=1.20.0
EOF
            print_success "Updated requirements.txt with pytest"
        fi

        # Create .nvim.lua for Python LSP/DAP/Molten support
        if [[ ! -f ".nvim.lua" ]]; then
            cat > .nvim.lua << 'EOF'
-- Project-specific configuration for Python

-- Configure Python virtual environment
vim.g.python3_host_prog = vim.fn.getcwd() .. '/.venv/bin/python'

-- Project keymaps
vim.keymap.set('n', '<leader>ct', ':!python -m pytest<CR>', { desc = '[C]ode: Run [T]ests' })
vim.keymap.set('n', '<leader>cr', ':!python %<CR>', { desc = '[C]ode: [R]un current file' })
vim.keymap.set('n', '<leader>cc', ':!find . -type d -name "__pycache__" -exec rm -rf {} + 2>/dev/null<CR>', { desc = '[C]ode: [C]lean cache' })
EOF
            print_success "Created .nvim.lua for Python LSP/DAP configuration"
        fi

        # Display workflow tips for Python projects
        echo ""
        print_success "ðŸ Python Project Ready!"
        echo ""
        echo "$(print_info "Next steps:")"
        echo "  1. Enter project:  cd $PROJECT_NAME"
        echo "  2. Enable env:     direnv allow  # This creates & activates venv automatically"
        echo "  3. Install deps:   uv pip install -r requirements.txt"
        echo ""
        echo "$(print_success "Run your code:")"
        echo "  â€¢ Module:    python ${PROJECT_NAME//-/_}.py"
        echo "  â€¢ Tests:     pytest"
        echo "  â€¢ Coverage:  pytest --cov=${PROJECT_NAME//-/_}"
        echo "  â€¢ Verbose:   pytest -v"
        echo ""
        echo "$(print_success "Test features:")"
        echo "  âœ“ Unit tests with multiple test cases"
        echo "  âœ“ Parametrized tests for multiple inputs"
        echo "  âœ“ Fixtures for reusable test data"
        echo "  âœ“ Error handling and edge case tests"
        echo ""
        echo "$(print_info "Tip:") The module includes greet(), add_numbers(), and fibonacci() functions"
        echo "      with comprehensive test coverage as examples to build upon."
        ;;


    cpp)
        # Always create CMakeLists.txt with Conan support
        if [[ ! -f "CMakeLists.txt" ]]; then
            cat > CMakeLists.txt << EOF
cmake_minimum_required(VERSION 3.20)

# Include Conan toolchain if it exists
if(EXISTS \${CMAKE_BINARY_DIR}/conan_toolchain.cmake)
    include(\${CMAKE_BINARY_DIR}/conan_toolchain.cmake)
endif()

project($PROJECT_NAME)

set(CMAKE_CXX_STANDARD $CPP_STANDARD)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Find packages provided by Conan
# Example: find_package(fmt REQUIRED)

# Add your targets here
add_executable(\${PROJECT_NAME} src/main.cpp)

# Link libraries
# Example: target_link_libraries(\${PROJECT_NAME} PRIVATE fmt::fmt)

# Testing configuration
if(NOT "$TEST_FRAMEWORK" STREQUAL "none")
    enable_testing()

    if("$TEST_FRAMEWORK" STREQUAL "gtest")
        find_package(GTest REQUIRED)
        add_executable(\${PROJECT_NAME}_test tests/test_main.cpp)
        target_link_libraries(\${PROJECT_NAME}_test PRIVATE GTest::gtest_main)
        add_test(NAME \${PROJECT_NAME}_test COMMAND \${PROJECT_NAME}_test)
    elseif("$TEST_FRAMEWORK" STREQUAL "catch2")
        find_package(Catch2 REQUIRED)
        add_executable(\${PROJECT_NAME}_test tests/test_main.cpp)
        target_link_libraries(\${PROJECT_NAME}_test PRIVATE Catch2::Catch2WithMain)
        add_test(NAME \${PROJECT_NAME}_test COMMAND \${PROJECT_NAME}_test)
    endif()
endif()
EOF
            mkdir -p src
            if [[ ! -f "src/main.cpp" ]]; then
                cat > src/main.cpp << EOF
#include <iostream>

int main() {
    std::cout << "Hello from $PROJECT_NAME!" << std::endl;
    return 0;
}
EOF
            fi

            # Create test file if testing is enabled
            if [[ "$TEST_FRAMEWORK" != "none" ]]; then
                mkdir -p tests
                if [[ ! -f "tests/test_main.cpp" ]]; then
                    if [[ "$TEST_FRAMEWORK" == "gtest" ]]; then
                        cat > tests/test_main.cpp << 'EOF'
#include <gtest/gtest.h>

// Example test case
TEST(BasicTest, SampleTest) {
    EXPECT_EQ(2 + 2, 4);
    EXPECT_TRUE(true);
}

// You can add more test cases here
TEST(BasicTest, StringTest) {
    std::string greeting = "Hello, World!";
    EXPECT_EQ(greeting.length(), 13);
}

// Test with custom setup
class MathTest : public ::testing::Test {
protected:
    void SetUp() override {
        // Setup code here
    }

    void TearDown() override {
        // Teardown code here
    }
};

TEST_F(MathTest, Addition) {
    EXPECT_EQ(1 + 1, 2);
    EXPECT_EQ(10 + 5, 15);
}
EOF
                    elif [[ "$TEST_FRAMEWORK" == "catch2" ]]; then
                        cat > tests/test_main.cpp << 'EOF'
#include <catch2/catch_test_macros.hpp>

TEST_CASE("Basic functionality", "[basic]") {
    REQUIRE(2 + 2 == 4);
    REQUIRE(true);
}

TEST_CASE("String operations", "[string]") {
    std::string greeting = "Hello, World!";
    REQUIRE(greeting.length() == 13);
}

TEST_CASE("Math operations", "[math]") {
    REQUIRE(1 + 1 == 2);
    REQUIRE(10 + 5 == 15);
}
EOF
                    fi
                    print_success "Created tests/test_main.cpp"
                fi
            fi

            print_success "Created CMakeLists.txt and src/main.cpp"
        fi

        # Always create conanfile.txt
        if [[ ! -f "conanfile.txt" ]]; then
            cat > conanfile.txt << EOF
[requires]
# Add your dependencies here, for example:
# fmt/10.1.0
# boost/1.82.0
# spdlog/1.12.0

[generators]
CMakeDeps
CMakeToolchain

[layout]
cmake_layout

[options]
# Add package options here if needed

[imports]
# Import files from dependencies if needed
EOF
            print_success "Created conanfile.txt"
        fi

        # Create local Conan profiles with correct compiler version
        if [[ "$PACKAGE_MANAGER" == "conan" ]] && [[ ! -f ".conan2/release" ]]; then
            mkdir -p .conan2

            # Create release profile
            cat > .conan2/release << EOF
[settings]
arch=armv8
build_type=Release
compiler=clang
compiler.cppstd=$CPP_STANDARD
compiler.libcxx=libc++
compiler.version=$LLVM_VERSION
os=Macos

[conf]
tools.build:exelinkflags=['-fuse-ld=lld']
tools.build:jobs=10
tools.build:sharedlinkflags=['-fuse-ld=lld']
tools.cmake.cmaketoolchain:extra_variables={'CMAKE_EXPORT_COMPILE_COMMANDS': 'ON'}
tools.cmake.cmaketoolchain:generator=Ninja

[buildenv]
CC=clang
CXX=clang++
LD=lld
CMAKE_EXPORT_COMPILE_COMMANDS=ON
EOF

            # Create debug profile
            cat > .conan2/debug << EOF
[settings]
arch=armv8
build_type=Debug
compiler=clang
compiler.cppstd=$CPP_STANDARD
compiler.libcxx=libc++
compiler.version=$LLVM_VERSION
os=Macos

[conf]
tools.build:exelinkflags=['-fuse-ld=lld']
tools.build:jobs=10
tools.build:sharedlinkflags=['-fuse-ld=lld']
tools.cmake.cmaketoolchain:extra_variables={'CMAKE_EXPORT_COMPILE_COMMANDS': 'ON'}
tools.cmake.cmaketoolchain:generator=Ninja

[buildenv]
CC=clang
CXX=clang++
LD=lld
CMAKE_EXPORT_COMPILE_COMMANDS=ON
EOF
            print_success "Created local Conan profiles (release and debug)"
        fi

        # Create .nvim.lua for C++ LSP/DAP support
        if [[ ! -f ".nvim.lua" ]]; then
            cat > .nvim.lua << 'EOF'
-- Project-specific configuration for C++

-- Auto-link compile_commands.json from build directory
vim.api.nvim_create_autocmd("BufReadPost", {
    pattern = "*",
    callback = function()
        local build_cc = vim.fn.getcwd() .. "/build/compile_commands.json"
        local root_cc = vim.fn.getcwd() .. "/compile_commands.json"
        if vim.fn.filereadable(build_cc) == 1 and vim.fn.filereadable(root_cc) == 0 then
            vim.fn.system("ln -sf build/compile_commands.json .")
        end
    end,
    once = true,
})

-- Project keymaps
vim.keymap.set('n', '<leader>cb', ':!cmake --build build --preset conan-release<CR>', { desc = '[C]ode: [B]uild project' })
vim.keymap.set('n', '<leader>ct', ':!ctest --preset conan-release<CR>', { desc = '[C]ode: Run [T]ests' })
vim.keymap.set('n', '<leader>cc', ':!cmake --build build --target clean<CR>', { desc = '[C]ode: [C]lean' })
vim.keymap.set('n', '<leader>ci', ':!conan install . --profile ./.conan2/release --build=missing<CR>', { desc = '[C]ode: [I]nstall deps' })
EOF
            print_success "Created .nvim.lua for C++ LSP/DAP configuration"
        fi

        # Display workflow tips for C++ projects
        echo ""
        print_success "ðŸ”§ C++ Project Ready!"
        echo ""
        echo "$(print_info "Next steps:")"
        echo "  1. Enter project:     cd $PROJECT_NAME"
        echo "  2. Enter dev env:     direnv allow"

        if [[ "$PACKAGE_MANAGER" == "conan" ]]; then
            echo "  3. Install deps:      conan install . --profile ./.conan2/release --build=missing"
            echo "  4. Configure:         cmake --preset conan-release"
            echo "  5. Build:             cmake --build --preset conan-release"
            echo "  6. Run tests:         ctest --preset conan-release"
        else
            echo "  3. Configure:         cmake -S . -B build -DCMAKE_BUILD_TYPE=Release"
            echo "  4. Build:             cmake --build build"
            echo "  5. Run tests:         cd build && ctest"
        fi

        echo ""
        echo "$(print_success "Run your code:")"
        echo "  â€¢ Main app:     ./build/Release/$PROJECT_NAME"
        echo "  â€¢ All tests:    ctest --preset conan-release"
        echo "  â€¢ Verbose:      ctest --preset conan-release -V"
        echo "  â€¢ Single test:  ./build/Release/${PROJECT_NAME}_test"

        if [[ "$TEST_FRAMEWORK" != "none" ]]; then
            echo ""
            echo "$(print_success "Test features:")"
            if [[ "$TEST_FRAMEWORK" == "gtest" ]]; then
                echo "  âœ“ Google Test framework with example tests"
                echo "  âœ“ Test fixtures for setup/teardown"
                echo "  âœ“ Multiple test cases and assertions"
            elif [[ "$TEST_FRAMEWORK" == "catch2" ]]; then
                echo "  âœ“ Catch2 framework with BDD-style tests"
                echo "  âœ“ Tagged test cases for organization"
                echo "  âœ“ REQUIRE and CHECK assertions"
            fi
        fi

        echo ""
        echo "$(print_info "Tip:") Conan profiles use Nix store paths for consistent toolchain versions."
        echo "      Or debug: conan install . --profile ./.conan2/debug --build=missing"
        ;;

    latex)
        # Create main LaTeX document
        if [[ ! -f "main.tex" ]]; then
            cat > main.tex << EOF
\\documentclass[12pt]{article}
\\usepackage[utf8]{inputenc}
\\usepackage{amsmath}
\\usepackage{amsfonts}
\\usepackage{graphicx}
\\usepackage{hyperref}

\\title{$PROJECT_NAME}
\\author{Your Name}
\\date{\\today}

\\begin{document}

\\maketitle

\\section{Introduction}
This document demonstrates some beautiful partial differential equations.

\\section{Classic PDEs}

\\subsection{Heat Equation}
The heat equation describes the distribution of heat in a given region over time:
\\begin{equation}
\\frac{\\partial u}{\\partial t} = \\alpha \\nabla^2 u
\\end{equation}

\\subsection{Wave Equation}
The wave equation governs the behavior of waves:
\\begin{equation}
\\frac{\\partial^2 u}{\\partial t^2} = c^2 \\nabla^2 u
\\end{equation}

\\subsection{SchrÃ¶dinger Equation}
The time-dependent SchrÃ¶dinger equation in quantum mechanics:
\\begin{equation}
i\\hbar \\frac{\\partial \\psi}{\\partial t} = \\hat{H} \\psi
\\end{equation}

\\subsection{Navier-Stokes Equations}
The incompressible Navier-Stokes equations for fluid dynamics:
\\begin{align}
\\nabla \\cdot \\mathbf{u} &= 0 \\\\
\\frac{\\partial \\mathbf{u}}{\\partial t} + (\\mathbf{u} \\cdot \\nabla) \\mathbf{u} &= -\\frac{1}{\\rho} \\nabla p + \\nu \\nabla^2 \\mathbf{u}
\\end{align}

\\subsection{Maxwell's Equations}
The electromagnetic field equations:
\\begin{align}
\\nabla \\cdot \\mathbf{E} &= \\frac{\\rho}{\\varepsilon_0} \\\\
\\nabla \\cdot \\mathbf{B} &= 0 \\\\
\\nabla \\times \\mathbf{E} &= -\\frac{\\partial \\mathbf{B}}{\\partial t} \\\\
\\nabla \\times \\mathbf{B} &= \\mu_0 \\mathbf{J} + \\mu_0 \\varepsilon_0 \\frac{\\partial \\mathbf{E}}{\\partial t}
\\end{align}

% Include figures from figures/ directory
% \\includegraphics[width=0.8\\textwidth]{figures/solution_plot.png}

% Include sections from sections/ directory
% \\input{sections/numerical_methods}

\\end{document}
EOF
            print_success "Created main.tex"
        fi

        # Create .latexmkrc configuration
        if [[ ! -f ".latexmkrc" ]]; then
            cat > .latexmkrc << 'EOF'
# LaTeX build configuration
$pdf_mode = 1;
$pdflatex = 'pdflatex -interaction=nonstopmode -synctex=1 %O %S';
$pdf_previewer = 'open -a Preview';
$clean_ext = 'synctex.gz synctex.gz(busy) run.xml tex.bak bbl bcf fdb_latexmk run tdo %R-blx.bib';

# Auto-clean on build
$cleanup_mode = 1;
$cleanup_includes_generated = 1;

# Output directory
$out_dir = 'build';
$aux_dir = 'build';
EOF
            print_success "Created .latexmkrc"
        fi

        # Create standard LaTeX directories
        mkdir -p figures sections build
        print_success "Created directories: figures/, sections/, build/"

        # Create .nvim.lua for LaTeX LSP support
        if [[ ! -f ".nvim.lua" ]]; then
            cat > .nvim.lua << 'EOF'
-- Project-specific configuration for LaTeX

-- LaTeX-specific buffer settings
vim.api.nvim_create_autocmd("FileType", {
    pattern = "tex",
    callback = function()
        vim.opt_local.wrap = true
        vim.opt_local.linebreak = true
        vim.opt_local.spell = true
    end,
})

-- Project keymaps
vim.keymap.set('n', '<leader>cb', ':!latexmk -pdf %<CR>', { desc = '[C]ode: [B]uild PDF' })
vim.keymap.set('n', '<leader>cc', ':!latexmk -c<CR>', { desc = '[C]ode: [C]lean aux files' })
vim.keymap.set('n', '<leader>cv', ':!open build/*.pdf<CR>', { desc = '[C]ode: [V]iew PDF' })
EOF
            print_success "Created .nvim.lua for LaTeX LSP configuration"
        fi
        ;;
    cpp-python)
        # Create directory structure
        mkdir -p src python tests

        # Create CMakeLists.txt
        cat > CMakeLists.txt << 'EOF'
cmake_minimum_required(VERSION 3.18)
project(PROJECT_NAME)

set(CMAKE_CXX_STANDARD CPP_STANDARD)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Fix for macOS compilation
if(APPLE)
    add_compile_definitions(_DARWIN_C_SOURCE)
endif()

# Find Python
find_package(Python COMPONENTS Interpreter Development REQUIRED)

# Find pybind11 (from Conan)
find_package(pybind11 REQUIRED)

# Create the Python module
pybind11_add_module(MODULE_NAME
    src/bindings.cpp
    src/math_ops.cpp
)

# Set properties for the module
target_compile_features(MODULE_NAME PRIVATE cxx_std_CPP_STANDARD)
target_include_directories(MODULE_NAME PRIVATE src)

# Create C++ tests executable
enable_testing()
find_package(GTest REQUIRED)
add_executable(test_cpp tests/test_cpp.cpp src/math_ops.cpp)
target_include_directories(test_cpp PRIVATE src)
target_link_libraries(test_cpp GTest::GTest GTest::Main)
add_test(NAME test_cpp COMMAND test_cpp)
EOF
        # Replace placeholders
        if [[ -f CMakeLists.txt ]]; then
            # Use GNU sed syntax (gnused is installed as 'sed' in nix)
            sed -i "s/PROJECT_NAME/$PROJECT_NAME/g" CMakeLists.txt
            sed -i "s/MODULE_NAME/${PROJECT_NAME//-/_}/g" CMakeLists.txt
            sed -i "s/CPP_STANDARD/$CPP_STANDARD/g" CMakeLists.txt
            print_success "Created CMakeLists.txt"
        fi

        # Create C++ header
        cat > src/math_ops.h << 'EOF'
#ifndef MATH_OPS_H
#define MATH_OPS_H

#include <vector>
#include <string>

namespace math_ops {

// Simple math operations to demonstrate bindings
double add(double a, double b);
double multiply(double a, double b);

// Vector operations
std::vector<double> elementwise_add(const std::vector<double>& a,
                                    const std::vector<double>& b);

// Example class
class Calculator {
private:
    double result_;

public:
    Calculator() : result_(0.0) {}

    void add(double value);
    void multiply(double value);
    void reset();
    double get_result() const;

    // Example of exception throwing
    double divide(double value);
};

// Function that throws exception
double safe_divide(double a, double b);

} // namespace math_ops

#endif // MATH_OPS_H
EOF
        print_success "Created src/math_ops.h"

        # Create C++ implementation
        cat > src/math_ops.cpp << 'EOF'
#include "math_ops.h"
#include <stdexcept>
#include <algorithm>

namespace math_ops {

double add(double a, double b) {
    return a + b;
}

double multiply(double a, double b) {
    return a * b;
}

std::vector<double> elementwise_add(const std::vector<double>& a,
                                    const std::vector<double>& b) {
    if (a.size() != b.size()) {
        throw std::runtime_error("Vectors must have the same size");
    }

    std::vector<double> result(a.size());
    std::transform(a.begin(), a.end(), b.begin(), result.begin(),
                   [](double x, double y) { return x + y; });
    return result;
}

void Calculator::add(double value) {
    result_ += value;
}

void Calculator::multiply(double value) {
    result_ *= value;
}

void Calculator::reset() {
    result_ = 0.0;
}

double Calculator::get_result() const {
    return result_;
}

double Calculator::divide(double value) {
    if (value == 0.0) {
        throw std::domain_error("Division by zero");
    }
    result_ /= value;
    return result_;
}

double safe_divide(double a, double b) {
    if (b == 0.0) {
        throw std::domain_error("Division by zero");
    }
    return a / b;
}

} // namespace math_ops
EOF
        print_success "Created src/math_ops.cpp"

        # Create pybind11 bindings
        cat > src/bindings.cpp << 'EOF'
// Fix for macOS compilation issues with Python.h
#ifdef __APPLE__
#include <cstdint>
#include <stdint.h>
#endif

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/numpy.h>
#include "math_ops.h"

namespace py = pybind11;

PYBIND11_MODULE(MODULE_NAME, m) {
    m.doc() = "C++ math operations exposed to Python via pybind11";

    // Simple functions
    m.def("add", &math_ops::add, "Add two numbers",
          py::arg("a"), py::arg("b"));

    m.def("multiply", &math_ops::multiply, "Multiply two numbers",
          py::arg("a"), py::arg("b"));

    // Vector function
    m.def("elementwise_add", &math_ops::elementwise_add,
          "Add two vectors element-wise",
          py::arg("a"), py::arg("b"));

    // Function with exception handling
    m.def("safe_divide", &math_ops::safe_divide,
          "Safely divide two numbers (throws on division by zero)",
          py::arg("a"), py::arg("b"));

    // Class binding
    py::class_<math_ops::Calculator>(m, "Calculator")
        .def(py::init<>())
        .def("add", &math_ops::Calculator::add, "Add to result")
        .def("multiply", &math_ops::Calculator::multiply, "Multiply result")
        .def("reset", &math_ops::Calculator::reset, "Reset result to 0")
        .def("divide", &math_ops::Calculator::divide,
             "Divide result (throws on division by zero)")
        .def_property_readonly("result", &math_ops::Calculator::get_result,
                               "Get current result");

    // Module-level attributes
    m.attr("__version__") = "0.1.0";
}
EOF
        # Replace module name placeholder
        if [[ -f src/bindings.cpp ]]; then
            sed -i "s/MODULE_NAME/${PROJECT_NAME//-/_}/g" src/bindings.cpp
            print_success "Created src/bindings.cpp"
        fi

        # Create setup.py
        cat > setup.py << EOF
from setuptools import setup, Extension
from pybind11.setup_helpers import Pybind11Extension, build_ext

ext_modules = [
    Pybind11Extension(
        "${PROJECT_NAME//-/_}",
        ["src/bindings.cpp", "src/math_ops.cpp"],
        include_dirs=["src"],
        cxx_std=${CPP_STANDARD},
    ),
]

setup(
    name="${PROJECT_NAME}",
    version="0.1.0",
    author="Your Name",
    author_email="your.email@example.com",
    description="C++ extension module with pybind11",
    ext_modules=ext_modules,
    cmdclass={"build_ext": build_ext},
    zip_safe=False,
    python_requires=">=3.7",
)
EOF
        print_success "Created setup.py"

        # Create Python example
        cat > python/example.py << EOF
#!/usr/bin/env python3
"""Example usage of the C++ extension module."""

import sys
import os

# Add build directory to path for development
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'build'))

import ${PROJECT_NAME//-/_} as cpp_module

def main():
    print(f"Module version: {cpp_module.__version__}")
    print()

    # Simple operations
    a, b = 10.5, 20.3
    print(f"add({a}, {b}) = {cpp_module.add(a, b)}")
    print(f"multiply({a}, {b}) = {cpp_module.multiply(a, b)}")
    print()

    # Vector operations
    vec1 = [1.0, 2.0, 3.0]
    vec2 = [4.0, 5.0, 6.0]
    result = cpp_module.elementwise_add(vec1, vec2)
    print(f"elementwise_add({vec1}, {vec2}) = {result}")
    print()

    # Using the Calculator class
    calc = cpp_module.Calculator()
    print("Calculator demo:")
    calc.add(10)
    print(f"  After add(10): {calc.result}")
    calc.multiply(3)
    print(f"  After multiply(3): {calc.result}")
    calc.divide(2)
    print(f"  After divide(2): {calc.result}")
    calc.reset()
    print(f"  After reset(): {calc.result}")
    print()

    # Exception handling
    try:
        result = cpp_module.safe_divide(10, 0)
    except Exception as e:
        print(f"Caught exception: {e}")

    # Successful division
    result = cpp_module.safe_divide(10, 2)
    print(f"safe_divide(10, 2) = {result}")

if __name__ == "__main__":
    main()
EOF
        print_success "Created python/example.py"

        # Create C++ test
        cat > tests/test_cpp.cpp << 'EOF'
#include <gtest/gtest.h>
#include "math_ops.h"

TEST(MathOpsTest, AddFunction) {
    EXPECT_DOUBLE_EQ(math_ops::add(2.0, 3.0), 5.0);
    EXPECT_DOUBLE_EQ(math_ops::add(-1.0, 1.0), 0.0);
}

TEST(MathOpsTest, MultiplyFunction) {
    EXPECT_DOUBLE_EQ(math_ops::multiply(2.0, 3.0), 6.0);
    EXPECT_DOUBLE_EQ(math_ops::multiply(-2.0, 3.0), -6.0);
}

TEST(MathOpsTest, VectorAdd) {
    std::vector<double> a = {1.0, 2.0, 3.0};
    std::vector<double> b = {4.0, 5.0, 6.0};
    std::vector<double> expected = {5.0, 7.0, 9.0};

    auto result = math_ops::elementwise_add(a, b);

    ASSERT_EQ(result.size(), expected.size());
    for (size_t i = 0; i < result.size(); ++i) {
        EXPECT_DOUBLE_EQ(result[i], expected[i]);
    }
}

TEST(MathOpsTest, VectorAddSizeMismatch) {
    std::vector<double> a = {1.0, 2.0};
    std::vector<double> b = {4.0, 5.0, 6.0};

    EXPECT_THROW(math_ops::elementwise_add(a, b), std::runtime_error);
}

TEST(CalculatorTest, BasicOperations) {
    math_ops::Calculator calc;

    EXPECT_DOUBLE_EQ(calc.get_result(), 0.0);

    calc.add(10.0);
    EXPECT_DOUBLE_EQ(calc.get_result(), 10.0);

    calc.multiply(3.0);
    EXPECT_DOUBLE_EQ(calc.get_result(), 30.0);

    calc.divide(2.0);
    EXPECT_DOUBLE_EQ(calc.get_result(), 15.0);

    calc.reset();
    EXPECT_DOUBLE_EQ(calc.get_result(), 0.0);
}

TEST(CalculatorTest, DivisionByZero) {
    math_ops::Calculator calc;
    calc.add(10.0);

    EXPECT_THROW(calc.divide(0.0), std::domain_error);
}

TEST(SafeDivideTest, NormalDivision) {
    EXPECT_DOUBLE_EQ(math_ops::safe_divide(10.0, 2.0), 5.0);
}

TEST(SafeDivideTest, DivisionByZero) {
    EXPECT_THROW(math_ops::safe_divide(10.0, 0.0), std::domain_error);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
EOF
        print_success "Created tests/test_cpp.cpp"

        # Create Python test
        cat > tests/test_python.py << EOF
#!/usr/bin/env python3
"""Tests for the Python bindings of the C++ module."""

import sys
import os
import pytest

# Add build directory to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'build'))

import ${PROJECT_NAME//-/_} as cpp_module

def test_add():
    assert cpp_module.add(2.0, 3.0) == 5.0
    assert cpp_module.add(-1.0, 1.0) == 0.0
    assert cpp_module.add(0.0, 0.0) == 0.0

def test_multiply():
    assert cpp_module.multiply(2.0, 3.0) == 6.0
    assert cpp_module.multiply(-2.0, 3.0) == -6.0
    assert cpp_module.multiply(0.0, 100.0) == 0.0

def test_elementwise_add():
    vec1 = [1.0, 2.0, 3.0]
    vec2 = [4.0, 5.0, 6.0]
    result = cpp_module.elementwise_add(vec1, vec2)
    assert result == [5.0, 7.0, 9.0]

def test_elementwise_add_size_mismatch():
    vec1 = [1.0, 2.0]
    vec2 = [4.0, 5.0, 6.0]
    with pytest.raises(ValueError):
        cpp_module.elementwise_add(vec1, vec2)

def test_calculator_basic():
    calc = cpp_module.Calculator()
    assert calc.result == 0.0

    calc.add(10.0)
    assert calc.result == 10.0

    calc.multiply(3.0)
    assert calc.result == 30.0

    calc.divide(2.0)
    assert calc.result == 15.0

    calc.reset()
    assert calc.result == 0.0

def test_calculator_division_by_zero():
    calc = cpp_module.Calculator()
    calc.add(10.0)

    with pytest.raises(ValueError):
        calc.divide(0.0)

def test_safe_divide():
    assert cpp_module.safe_divide(10.0, 2.0) == 5.0
    assert cpp_module.safe_divide(15.0, 3.0) == 5.0

    with pytest.raises(ValueError):
        cpp_module.safe_divide(10.0, 0.0)

def test_module_version():
    assert hasattr(cpp_module, '__version__')
    assert isinstance(cpp_module.__version__, str)

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
EOF
        print_success "Created tests/test_python.py"

        # Create requirements.txt with dependencies
        cat > requirements.txt << 'EOF'
pytest>=7.0.0
numpy>=1.20.0
EOF
        print_success "Created requirements.txt with dependencies"

        # Create conanfile.txt for C++ dependencies
        cat > conanfile.txt << 'EOF'
[requires]
pybind11/2.11.1
gtest/1.14.0

[generators]
CMakeDeps
CMakeToolchain

[options]

[imports]
EOF
        print_success "Created conanfile.txt for C++ dependencies"

        # Create local Conan profiles with correct compiler version
        if [[ ! -f ".conan2/release" ]]; then
            mkdir -p .conan2

            # Create release profile
            cat > .conan2/release << EOF
[settings]
arch=armv8
build_type=Release
compiler=clang
compiler.cppstd=$CPP_STANDARD
compiler.libcxx=libc++
compiler.version=$LLVM_VERSION
os=Macos

[conf]
tools.build:exelinkflags=['-fuse-ld=lld']
tools.build:jobs=10
tools.build:sharedlinkflags=['-fuse-ld=lld']
tools.cmake.cmaketoolchain:extra_variables={'CMAKE_EXPORT_COMPILE_COMMANDS': 'ON'}
tools.cmake.cmaketoolchain:generator=Ninja

[buildenv]
CC=clang
CXX=clang++
LD=lld
CMAKE_EXPORT_COMPILE_COMMANDS=ON
EOF

            # Create debug profile
            cat > .conan2/debug << EOF
[settings]
arch=armv8
build_type=Debug
compiler=clang
compiler.cppstd=$CPP_STANDARD
compiler.libcxx=libc++
compiler.version=$LLVM_VERSION
os=Macos

[conf]
tools.build:exelinkflags=['-fuse-ld=lld']
tools.build:jobs=10
tools.build:sharedlinkflags=['-fuse-ld=lld']
tools.cmake.cmaketoolchain:extra_variables={'CMAKE_EXPORT_COMPILE_COMMANDS': 'ON'}
tools.cmake.cmaketoolchain:generator=Ninja

[buildenv]
CC=clang
CXX=clang++
LD=lld
CMAKE_EXPORT_COMPILE_COMMANDS=ON
EOF
            print_success "Created local Conan profiles (release and debug)"
        fi

        # Create .nvim.lua for C++/Python hybrid support
        cat > .nvim.lua << 'EOF'
-- Project-specific configuration for C++/Python hybrid

-- Configure Python virtual environment
vim.g.python3_host_prog = vim.fn.getcwd() .. '/.venv/bin/python'

-- Auto-link compile_commands.json from build directory
vim.api.nvim_create_autocmd("BufReadPost", {
    pattern = "*",
    callback = function()
        local build_cc = vim.fn.getcwd() .. "/build/compile_commands.json"
        local root_cc = vim.fn.getcwd() .. "/compile_commands.json"
        if vim.fn.filereadable(build_cc) == 1 and vim.fn.filereadable(root_cc) == 0 then
            vim.fn.system("ln -sf build/compile_commands.json .")
        end
    end,
    once = true,
})

-- Project keymaps
vim.keymap.set('n', '<leader>cb', ':!cmake --build build<CR>', { desc = '[C]ode: [B]uild C++ extension' })
vim.keymap.set('n', '<leader>ct', ':!cd build && ctest<CR>', { desc = '[C]ode: Run C++ [T]ests' })
vim.keymap.set('n', '<leader>cp', ':!pytest<CR>', { desc = '[C]ode: Run [P]ython tests' })
vim.keymap.set('n', '<leader>cc', ':!cmake --build build --target clean<CR>', { desc = '[C]ode: [C]lean' })
vim.keymap.set('n', '<leader>cr', ':!python python/example.py<CR>', { desc = '[C]ode: [R]un example' })
EOF
        print_success "Created .nvim.lua for C++/Python hybrid LSP/DAP configuration"
        ;;
esac

print_success "Project initialized successfully!"