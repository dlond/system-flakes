#!/usr/bin/env bash

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Function to print colored output
print_info() { echo -e "${BLUE}ℹ ${NC} $1"; }
print_success() { echo -e "${GREEN}✓${NC} $1"; }
print_error() { echo -e "${RED}✗${NC} $1"; }
print_warning() { echo -e "${YELLOW}⚠${NC} $1"; }

# Function to show general usage
usage() {
    cat << EOF
$(print_info "Harmonix - Nix Project Initializer")

$(print_success "USAGE:")
  $(basename "$0") <language> [OPTIONS]
  $(basename "$0") <language> --help    # Show language-specific help

$(print_success "LANGUAGES:")
  python      Python with uv package manager
  cpp         C++ with modern toolchain
  cpp-python  C++ with Python bindings via pybind11
  latex       LaTeX document authoring

$(print_success "COMMON OPTIONS:")
  --name NAME       Project name (default: current directory)
  --help, -h        Show help (general or language-specific)

$(print_success "EXAMPLES:")
  $(basename "$0") python --name ml-project --py 3.12
  $(basename "$0") cpp --cpp 23 --llvm 21 --test-framework catch2
  $(basename "$0") cpp --package-manager vcpkg --analysis --docs
  $(basename "$0") latex --pandoc --scheme full

$(print_success "FOR LANGUAGE-SPECIFIC OPTIONS:")
  $(basename "$0") python --help
  $(basename "$0") cpp --help
  $(basename "$0") latex --help

$(print_info "Each project includes:")
  • Nix flake for reproducible environment
  • Direnv for automatic shell activation
  • Neovim LSP/DAP configuration
  • Language-specific starter files
  • Comprehensive .gitignore

EOF
    exit 0
}

# Language-specific help functions
python_help() {
    cat << EOF
$(print_info "Python Project Initializer")

$(print_success "USAGE:")
  $(basename "$0") python [OPTIONS]

$(print_success "OPTIONS:")
  --name NAME           Project name (default: current directory)
  --py VER              Python version: 3.10, 3.11, 3.12, 3.13, 3.14 (default: 3.11)
  --help                Show this help

$(print_success "WHAT YOU GET:")
  • Python environment (configurable version)
  • Virtual environment with uv package manager
  • LSP: basedpyright and ruff (configured for venv)
  • Formatter: black
  • Jupyter/Molten support for notebooks in neovim
  • requirements.txt for dependencies
  • .nvim.lua with venv-aware configuration

$(print_success "PACKAGE MANAGEMENT:")
  $(print_info "Nix provides:")
    - Python interpreter, uv, development tools
    - LSP servers, formatters, debuggers
    - System dependencies for packages

  $(print_info "uv manages (via requirements.txt):")
    - Project-specific Python packages
    - Version pinning with pip freeze

$(print_success "WORKFLOW:")
  1. Create project:       $(basename "$0") python --name myapp
  2. Enter directory:      cd myapp
  3. Add dependencies:     echo "pandas>=2.0" >> requirements.txt
  4. Install packages:     uv pip install -r requirements.txt
  5. Open in neovim:       nvim myapp.py
  6. Start Jupyter kernel: :MoltenInit python3

$(print_success "ADDING SYSTEM DEPENDENCIES:")
  Edit flake.nix to add packages needed by Python libraries:
    extraPackages = with pkgs; [
      postgresql  # for psycopg2
      libxml2     # for lxml
      gdal        # for geodjango
    ];

EOF
    exit 0
}

cpp_help() {
    cat << EOF
$(print_info "C++ Project Initializer")

$(print_success "USAGE:")
  $(basename "$0") cpp [OPTIONS]

$(print_success "OPTIONS:")
  --name NAME           Project name (default: current directory)
  --cpp STD             C++ standard: 11, 14, 17, 20, 23 (default: 20)
  --llvm V              LLVM version: 18, 19, 20, 21 (default: 20)
  --package-manager PM  Package manager: conan, vcpkg, cpm, none (default: conan)
  --test-framework TF   Test framework: gtest, catch2, doctest, boost, none (default: gtest)
  --bazel               Enable Bazel support
  --docs                Enable documentation tools (doxygen, graphviz)
  --analysis            Enable analysis tools (cppcheck, valgrind, etc.)
  --help                Show this help

$(print_success "WHAT YOU GET:")
  • Complete LLVM toolchain (clang, clang-tools, lld, lldb)
  • Build tools: CMake, Ninja, Conan (default), Google Test (default)
  • LSP: clangd with compile_commands.json support
  • Formatter: clang-format
  • CMakeLists.txt with configurable C++ standard
  • src/main.cpp starter file
  • .nvim.lua with project-aware configuration

$(print_success "WORKFLOW:")
  1. Create project:    $(basename "$0") cpp --name myapp
  2. Enter directory:   cd myapp
  3. Install deps:      conan install . --build=missing
  4. Configure build:   cmake --preset conan-release
  5. Build project:     cmake --build --preset conan-release

  # Without Conan (if no dependencies):
  1. Configure:         cmake -S . -B build -DCMAKE_EXPORT_COMPILE_COMMANDS=ON
  2. Build:             cmake --build build

$(print_success "COMPILE COMMANDS:")
  The .nvim.lua automatically links compile_commands.json from build/
  to project root for clangd to find it.

EOF
    exit 0
}

cpp_python_help() {
    cat << EOF
$(print_info "C++ + Python Hybrid Project Initializer")

$(print_success "USAGE:")
  $(basename "$0") cpp-python [OPTIONS]

$(print_success "OPTIONS:")
  --name NAME           Project name (default: current directory)
  --cpp STD             C++ standard: 11, 14, 17, 20, 23 (default: 20)
  --llvm V              LLVM version: 18, 19, 20, 21 (default: 20)
  --py VER              Python version: 3.10, 3.11, 3.12, 3.13, 3.14 (default: 3.11)
  --help                Show this help

$(print_success "WHAT YOU GET:")
  • Complete LLVM toolchain for C++
  • Python environment with uv package manager
  • pybind11 for C++/Python bindings
  • Example C++ module with Python bindings
  • Python script using the C++ module
  • CMakeLists.txt configured for Python extensions
  • Tests for both C++ and Python code

$(print_success "PROJECT STRUCTURE:")
  src/
    ├── bindings.cpp    # pybind11 module definition
    ├── math_ops.cpp    # C++ implementation
    └── math_ops.h      # C++ header
  python/
    └── example.py      # Python usage example
  tests/
    ├── test_cpp.cpp    # C++ unit tests
    └── test_python.py  # Python unit tests
  CMakeLists.txt        # Build configuration
  setup.py              # Python package setup

$(print_success "WORKFLOW:")
  1. Create project:    $(basename "$0") cpp-python --name mylib
  2. Enter directory:   cd mylib
  3. Configure:         cmake -S . -B build -DPYTHON_EXECUTABLE=\$(which python)
  4. Build:             cmake --build build
  5. Install:           pip install -e .
  6. Test C++:          ./build/tests/test_cpp
  7. Test Python:       pytest tests/

$(print_success "FEATURES:")
  • Automatic Python venv creation with uv
  • Example demonstrates passing arrays between C++ and Python
  • Includes exception handling across language boundary
  • CMake automatically finds Python and pybind11
  • Tests demonstrate both C++ and Python usage

EOF
    exit 0
}

latex_help() {
    cat << EOF
$(print_info "LaTeX Project Initializer")

$(print_success "USAGE:")
  $(basename "$0") latex [OPTIONS]

$(print_success "OPTIONS:")
  --name NAME       Project name (default: current directory)
  --scheme SCHEME   TeX scheme: basic, small, medium, full (default: medium)
  --pandoc          Enable Pandoc for markdown conversion
  --biber           Enable Biber for bibliography
  --graphics        Enable graphics tools (inkscape, gnuplot)
  --python          Enable Python integration (pythontex)
  --help            Show this help

$(print_success "WHAT YOU GET:")
  • TeXLive distribution (size based on scheme)
  • LSP: texlab for completion and diagnostics
  • Build tool: latexmk for continuous compilation
  • main.tex starter document
  • .latexmkrc configuration
  • Directories: figures/, sections/

$(print_success "SCHEMES:")
  basic   - Minimal TeX installation
  small   - Basic document classes
  medium  - Most packages, recommended (default)
  full    - Everything including obscure packages

$(print_success "OPTIONAL FEATURES:")
  $(print_info "Pandoc (--pandoc):")
    - Convert between markdown, LaTeX, Word, etc.
    - Pandoc filters for custom processing

  $(print_info "Graphics (--graphics):")
    - Inkscape for SVG editing
    - Gnuplot for data plots
    - ImageMagick for conversions

$(print_success "WORKFLOW:")
  1. Create project:      $(basename "$0") latex --name paper --pandoc
  2. Enter directory:     cd paper
  3. Continuous build:    latexmk -pvc -pdf main.tex
  4. Open in neovim:      nvim main.tex
  5. Convert markdown:    pandoc input.md -o output.tex

$(print_success "LATEXMK:")
  The .latexmkrc is configured for:
    - PDF output with synctex
    - Automatic viewer refresh
    - Comprehensive cleanup

EOF
    exit 0
}

# Parse arguments
PROJECT_TYPE=""
PROJECT_NAME="$(basename "$PWD")"
# Molten/Jupyter now always included for Python
SCHEME="medium"
PANDOC=false
BIBER=false
GRAPHICS=false
PYTHON_TEX=false
# Version selections (keep Python default in sync with packages.nix!)
PYTHON_VERSION="3.11"
CPP_STANDARD="20"
LLVM_VERSION="20"
# C++ options
PACKAGE_MANAGER="conan"
TEST_FRAMEWORK="gtest"
WITH_BAZEL=false
WITH_DOCS=false
WITH_ANALYSIS=false

# Check if no arguments provided or just --help
if [[ $# -eq 0 ]] || [[ $1 == "--help" ]] || [[ $1 == "-h" ]]; then
    usage
fi

# Store the first argument as potential language
FIRST_ARG="$1"

# Check for language-specific help
if [[ $1 == "python" || $1 == "cpp" || $1 == "cpp-python" || $1 == "latex" ]]; then
    if [[ $# -eq 2 ]] && [[ $2 == "--help" || $2 == "-h" ]]; then
        case $1 in
            python)
                python_help
                ;;
            cpp)
                cpp_help
                ;;
            cpp-python)
                cpp_python_help
                ;;
            latex)
                latex_help
                ;;
        esac
    fi
fi

while [[ $# -gt 0 ]]; do
    case $1 in
        python|cpp|cpp-python|latex)
            PROJECT_TYPE="$1"
            shift
            ;;
        --name)
            PROJECT_NAME="$2"
            shift 2
            ;;
        --scheme)
            SCHEME="$2"
            shift 2
            ;;
        --pandoc)
            PANDOC=true
            shift
            ;;
        --biber)
            BIBER=true
            shift
            ;;
        --graphics)
            GRAPHICS=true
            shift
            ;;
        --python)
            PYTHON_TEX=true
            shift
            ;;
        --python-version|--py)
            PYTHON_VERSION="$2"
            shift 2
            ;;
        --cpp)
            CPP_STANDARD="$2"
            shift 2
            ;;
        --llvm)
            LLVM_VERSION="$2"
            shift 2
            ;;
        --package-manager)
            PACKAGE_MANAGER="$2"
            shift 2
            ;;
        --test-framework)
            TEST_FRAMEWORK="$2"
            shift 2
            ;;
        --bazel)
            WITH_BAZEL=true
            shift
            ;;
        --docs)
            WITH_DOCS=true
            shift
            ;;
        --analysis)
            WITH_ANALYSIS=true
            shift
            ;;
        --help|-h)
            if [[ -n "$PROJECT_TYPE" ]]; then
                case $PROJECT_TYPE in
                    python) python_help ;;
                    cpp) cpp_help ;;
                    latex) latex_help ;;
                esac
            else
                usage
            fi
            ;;
        *)
            print_error "Unknown option: $1"
            usage
            ;;
    esac
done

# Check if project type was specified
if [[ -z "$PROJECT_TYPE" ]]; then
    print_error "No project type specified"
    usage
fi

# Create project directory if name was provided and we're not already in it
if [[ "$PROJECT_NAME" != "$(basename "$PWD")" ]]; then
    if [[ -d "$PROJECT_NAME" ]]; then
        print_warning "Directory '$PROJECT_NAME' already exists"
        read -p "Continue in existing directory? (y/N) " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_info "Cancelled"
            exit 1
        fi
    else
        print_info "Creating directory: $PROJECT_NAME"
        mkdir -p "$PROJECT_NAME"
    fi
    cd "$PROJECT_NAME"
fi

# Check if files already exist
if [[ -f "flake.nix" ]]; then
    print_warning "flake.nix already exists in $(basename "$PWD")"
    read -p "Overwrite? (y/N) " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_info "Cancelled"
        exit 1
    fi
fi

# Create flake.nix based on project type
print_info "Creating flake.nix for $PROJECT_TYPE project: $PROJECT_NAME"

case $PROJECT_TYPE in
    python)
        cat > flake.nix << EOF
{
  description = "$PROJECT_NAME - Python project";

  inputs = {
    system-flakes.url = "github:dlond/system-flakes";
    nixpkgs.follows = "system-flakes/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, system-flakes, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.\${system};
      in
      {
        devShells.default = system-flakes.devShellTemplates.python {
          inherit pkgs;
          projectName = "$PROJECT_NAME";
          pythonVersion = "$PYTHON_VERSION";

          # Add project-specific packages here
          extraPackages = with pkgs; [
            # postgresql
            # redis
          ];
        };
      });
}
EOF
        ;;


    cpp)
        cat > flake.nix << EOF
{
  description = "$PROJECT_NAME - C++ project";

  inputs = {
    system-flakes.url = "github:dlond/system-flakes";
    nixpkgs.follows = "system-flakes/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, system-flakes, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.\${system};
      in
      {
        devShells.default = system-flakes.devShellTemplates.cpp {
          inherit pkgs;
          projectName = "$PROJECT_NAME";
          cppStandard = "$CPP_STANDARD";
          llvmVersion = "$LLVM_VERSION";
          packageManager = "$PACKAGE_MANAGER";
          testFramework = "$TEST_FRAMEWORK";
          withBazel = $WITH_BAZEL;
          withDocs = $WITH_DOCS;
          withAnalysis = $WITH_ANALYSIS;

          # Add project-specific packages here
          extraPackages = with pkgs; [
            # boost
            # opencv
          ];
        };
      });
}
EOF
        ;;

    latex)
        cat > flake.nix << EOF
{
  description = "$PROJECT_NAME - LaTeX document";

  inputs = {
    system-flakes.url = "github:dlond/system-flakes";
    nixpkgs.follows = "system-flakes/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, system-flakes, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.\${system};
      in
      {
        devShells.default = system-flakes.devShellTemplates.latex {
          inherit pkgs;
          projectName = "$PROJECT_NAME";
          scheme = "$SCHEME";
          withPandoc = $PANDOC;
          withBiber = $BIBER;
          withGraphics = $GRAPHICS;
          withPython = $PYTHON_TEX;

          # Add project-specific packages here
          extraPackages = with pkgs; [
            # aspell
            # aspellDicts.en
          ];
        };
      });
}
EOF
        ;;
    cpp-python)
        cat > flake.nix << EOF
{
  description = "$PROJECT_NAME - C++ + Python hybrid project";

  inputs = {
    system-flakes.url = "github:dlond/system-flakes";
    nixpkgs.follows = "system-flakes/nixpkgs";
    flake-utils.url = "github:numtide/flake-utils";
  };

  outputs = { self, system-flakes, nixpkgs, flake-utils }:
    flake-utils.lib.eachDefaultSystem (system:
      let
        pkgs = nixpkgs.legacyPackages.\${system};
      in
      {
        devShells.default = system-flakes.devShellTemplates."cpp-python" {
          inherit pkgs;
          projectName = "$PROJECT_NAME";
          cppStandard = "$CPP_STANDARD";
          llvmVersion = "$LLVM_VERSION";
          pythonVersion = "$PYTHON_VERSION";

          # Add project-specific packages here
          extraPackages = with pkgs; [
            # numpy
            # scipy
          ];
        };
      });
}
EOF
        ;;
esac

print_success "Created flake.nix"

# Create .envrc
print_info "Creating .envrc"
cat > .envrc << 'EOF'
use flake

# Project-specific environment setup
# Add any additional environment variables or setup here
EOF

print_success "Created .envrc"

# Create .gitignore if it doesn't exist
if [[ ! -f ".gitignore" ]]; then
    print_info "Creating .gitignore"
    cat > .gitignore << EOF
# Nix
result
result-*

# Direnv
.direnv/

# Editor
.nvim.lua
*.swp
*~

EOF

    # Add language-specific ignores
    case $PROJECT_TYPE in
        python)
            cat >> .gitignore << EOF
# Python
.venv/
venv/
*.pyc
__pycache__/
.pytest_cache/
*.egg-info/
dist/
build/
.ipynb_checkpoints/
EOF
            ;;
        cpp)
            cat >> .gitignore << EOF
# C++
build/
compile_commands.json
*.o
*.a
*.so
*.dylib
EOF
            ;;
        latex)
            cat >> .gitignore << EOF
# LaTeX
*.aux
*.log
*.out
*.pdf
*.synctex.gz
*.bbl
*.bcf
*.blg
*.fdb_latexmk
*.fls
*.run.xml
*.toc
EOF
            ;;
    esac

    print_success "Created .gitignore"
fi

# Create project-specific files
case $PROJECT_TYPE in
    python)
        if [[ ! -f "requirements.txt" ]]; then
            touch requirements.txt
            print_success "Created empty requirements.txt"
        fi
        if [[ ! -f "README.md" ]]; then
            echo "# $PROJECT_NAME" > README.md
            print_success "Created README.md"
        fi

        # Create .nvim.lua for Python LSP/DAP/Molten support
        if [[ ! -f ".nvim.lua" ]]; then
            cat > .nvim.lua << 'EOF'
-- Local nvim config for Python project
local venv_path = vim.fn.getcwd() .. '/.venv'
local venv_bin = venv_path .. '/bin'

-- Set Python host for nvim
vim.g.python3_host_prog = venv_bin .. '/python'

-- Override LSP settings for Python to use venv
vim.api.nvim_create_autocmd("LspAttach", {
    pattern = "*.py",
    callback = function(args)
        local client = vim.lsp.get_client_by_id(args.data.client_id)
        if not client then return end

        -- Configure basedpyright to use venv
        if client.name == "basedpyright" then
            client.config.settings = vim.tbl_deep_extend("force", client.config.settings or {}, {
                python = {
                    pythonPath = venv_bin .. '/python',
                    venvPath = vim.fn.getcwd(),
                    venv = '.venv',
                },
            })
            client.notify("workspace/didChangeConfiguration", { settings = client.config.settings })
        end

        -- Configure ruff to use venv
        if client.name == "ruff" then
            client.config.init_options = vim.tbl_deep_extend("force", client.config.init_options or {}, {
                settings = {
                    interpreter = { venv_bin .. '/python' },
                },
            })
        end
EOF

            if [[ "$MOLTEN" == "true" ]]; then
                cat >> .nvim.lua << 'EOF'

        -- Molten reminder
        vim.schedule(function()
            local kernels = vim.fn.system("jupyter kernelspec list")
            if kernels:match("python3") then
                vim.notify("Molten: Use :MoltenInit python3 to start kernel", vim.log.levels.INFO)
            end
        end)
EOF
            fi

            if [[ "$DEBUGGER" == "true" ]]; then
                cat >> .nvim.lua << 'EOF'

        -- Configure DAP for Python
        local dap_python = require('dap-python')
        if dap_python then
            dap_python.setup(venv_bin .. '/python')
        end
EOF
            fi

            cat >> .nvim.lua << 'EOF'
    end,
})
EOF
            print_success "Created .nvim.lua for Python LSP/DAP configuration"
        fi
        ;;


    cpp)
        # Always create CMakeLists.txt with Conan support
        if [[ ! -f "CMakeLists.txt" ]]; then
            cat > CMakeLists.txt << EOF
cmake_minimum_required(VERSION 3.20)

# Include Conan toolchain if it exists
if(EXISTS \${CMAKE_BINARY_DIR}/conan_toolchain.cmake)
    include(\${CMAKE_BINARY_DIR}/conan_toolchain.cmake)
endif()

project($PROJECT_NAME)

set(CMAKE_CXX_STANDARD $CPP_STANDARD)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Find packages provided by Conan
# Example: find_package(fmt REQUIRED)

# Add your targets here
add_executable(\${PROJECT_NAME} src/main.cpp)

# Link libraries
# Example: target_link_libraries(\${PROJECT_NAME} PRIVATE fmt::fmt)
EOF
            mkdir -p src
            if [[ ! -f "src/main.cpp" ]]; then
                cat > src/main.cpp << EOF
#include <iostream>

int main() {
    std::cout << "Hello from $PROJECT_NAME!" << std::endl;
    return 0;
}
EOF
            fi
            print_success "Created CMakeLists.txt and src/main.cpp"
        fi

        # Always create conanfile.txt
        if [[ ! -f "conanfile.txt" ]]; then
            cat > conanfile.txt << EOF
[requires]
# Add your dependencies here, for example:
# fmt/10.1.0
# boost/1.82.0
# spdlog/1.12.0

[generators]
CMakeDeps
CMakeToolchain

[layout]
cmake_layout

[options]
# Add package options here if needed

[imports]
# Import files from dependencies if needed
EOF
            print_success "Created conanfile.txt"
        fi

        # Create local Conan profiles with correct compiler version
        if [[ "$PACKAGE_MANAGER" == "conan" ]] && [[ ! -d ".conan2/profiles" ]]; then
            mkdir -p .conan2/profiles

            # Create release profile
            cat > .conan2/profiles/release << EOF
[settings]
arch=armv8
build_type=Release
compiler=clang
compiler.cppstd=$CPP_STANDARD
compiler.libcxx=libc++
compiler.version=$LLVM_VERSION
os=Macos

[conf]
tools.build:exelinkflags=['-fuse-ld=lld']
tools.build:jobs=10
tools.build:sharedlinkflags=['-fuse-ld=lld']
tools.cmake.cmaketoolchain:extra_variables={'CMAKE_EXPORT_COMPILE_COMMANDS': 'ON'}
tools.cmake.cmaketoolchain:generator=Ninja

[buildenv]
CC=clang
CXX=clang++
LD=lld
CMAKE_EXPORT_COMPILE_COMMANDS=ON
EOF

            # Create debug profile
            cat > .conan2/profiles/debug << EOF
[settings]
arch=armv8
build_type=Debug
compiler=clang
compiler.cppstd=$CPP_STANDARD
compiler.libcxx=libc++
compiler.version=$LLVM_VERSION
os=Macos

[conf]
tools.build:exelinkflags=['-fuse-ld=lld']
tools.build:jobs=10
tools.build:sharedlinkflags=['-fuse-ld=lld']
tools.cmake.cmaketoolchain:extra_variables={'CMAKE_EXPORT_COMPILE_COMMANDS': 'ON'}
tools.cmake.cmaketoolchain:generator=Ninja

[buildenv]
CC=clang
CXX=clang++
LD=lld
CMAKE_EXPORT_COMPILE_COMMANDS=ON
EOF
            print_success "Created local Conan profiles (release and debug)"
        fi

        # Create .nvim.lua for C++ LSP/DAP support
        if [[ ! -f ".nvim.lua" ]]; then
            cat > .nvim.lua << 'EOF'
-- Local nvim config for C++ project
local project_root = vim.fn.getcwd()

vim.api.nvim_create_autocmd("FileType", {
    pattern = { "c", "cpp", "cc", "cxx", "h", "hpp" },
    callback = function()
        -- CMake integration
        vim.notify("Build: Run 'conan install . --build=missing' then 'cmake --preset conan-release'", vim.log.levels.INFO)

        -- Auto-link compile_commands.json if it exists in build/
        local compile_commands_build = project_root .. "/build/compile_commands.json"
        local compile_commands_root = project_root .. "/compile_commands.json"
        if vim.fn.filereadable(compile_commands_build) == 1 and vim.fn.filereadable(compile_commands_root) == 0 then
            vim.fn.system("ln -s " .. compile_commands_build .. " " .. compile_commands_root)
            vim.notify("Linked compile_commands.json from build/", vim.log.levels.INFO)
        end

        -- Configure DAP for C++ (if nvim-dap is available)
        local ok, dap = pcall(require, 'dap')
        if ok then
            dap.configurations.cpp = {
                {
                    name = "Launch",
                    type = "lldb",
                    request = "launch",
                    program = function()
                        return vim.fn.input('Path to executable: ', project_root .. '/build/', 'file')
                    end,
                    cwd = project_root,
                    stopOnEntry = false,
                    args = {},
                },
            }
            -- Use same config for C
            dap.configurations.c = dap.configurations.cpp
        end
    end,
    once = true,
})
EOF
            print_success "Created .nvim.lua for C++ LSP/DAP configuration"
        fi
        ;;

    latex)
        if [[ ! -f "main.tex" ]]; then
            cat > main.tex << EOF
\\documentclass[12pt]{article}
\\usepackage[utf8]{inputenc}
\\usepackage{amsmath}
\\usepackage{graphicx}
\\usepackage{hyperref}

\\title{$PROJECT_NAME}
\\author{Your Name}
\\date{\\today}

\\begin{document}

\\maketitle

\\section{Introduction}
Start writing here...

\\end{document}
EOF
            print_success "Created main.tex"
        fi
        ;;
    cpp-python)
        # Create directory structure
        mkdir -p src python tests

        # Create CMakeLists.txt
        cat > CMakeLists.txt << 'EOF'
cmake_minimum_required(VERSION 3.18)
project(PROJECT_NAME)

set(CMAKE_CXX_STANDARD CPP_STANDARD)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Fix for macOS compilation
if(APPLE)
    add_compile_definitions(_DARWIN_C_SOURCE)
endif()

# Find Python
find_package(Python COMPONENTS Interpreter Development REQUIRED)

# Find pybind11 (from Conan)
find_package(pybind11 REQUIRED)

# Create the Python module
pybind11_add_module(MODULE_NAME
    src/bindings.cpp
    src/math_ops.cpp
)

# Set properties for the module
target_compile_features(MODULE_NAME PRIVATE cxx_std_CPP_STANDARD)
target_include_directories(MODULE_NAME PRIVATE src)

# Create C++ tests executable
enable_testing()
find_package(GTest REQUIRED)
add_executable(test_cpp tests/test_cpp.cpp src/math_ops.cpp)
target_include_directories(test_cpp PRIVATE src)
target_link_libraries(test_cpp GTest::GTest GTest::Main)
add_test(NAME test_cpp COMMAND test_cpp)
EOF
        # Replace placeholders
        if [[ -f CMakeLists.txt ]]; then
            # Use GNU sed syntax (gnused is installed as 'sed' in nix)
            sed -i "s/PROJECT_NAME/$PROJECT_NAME/g" CMakeLists.txt
            sed -i "s/MODULE_NAME/${PROJECT_NAME//-/_}/g" CMakeLists.txt
            sed -i "s/CPP_STANDARD/$CPP_STANDARD/g" CMakeLists.txt
            print_success "Created CMakeLists.txt"
        fi

        # Create C++ header
        cat > src/math_ops.h << 'EOF'
#ifndef MATH_OPS_H
#define MATH_OPS_H

#include <vector>
#include <string>

namespace math_ops {

// Simple math operations to demonstrate bindings
double add(double a, double b);
double multiply(double a, double b);

// Vector operations
std::vector<double> elementwise_add(const std::vector<double>& a,
                                    const std::vector<double>& b);

// Example class
class Calculator {
private:
    double result_;

public:
    Calculator() : result_(0.0) {}

    void add(double value);
    void multiply(double value);
    void reset();
    double get_result() const;

    // Example of exception throwing
    double divide(double value);
};

// Function that throws exception
double safe_divide(double a, double b);

} // namespace math_ops

#endif // MATH_OPS_H
EOF
        print_success "Created src/math_ops.h"

        # Create C++ implementation
        cat > src/math_ops.cpp << 'EOF'
#include "math_ops.h"
#include <stdexcept>
#include <algorithm>

namespace math_ops {

double add(double a, double b) {
    return a + b;
}

double multiply(double a, double b) {
    return a * b;
}

std::vector<double> elementwise_add(const std::vector<double>& a,
                                    const std::vector<double>& b) {
    if (a.size() != b.size()) {
        throw std::runtime_error("Vectors must have the same size");
    }

    std::vector<double> result(a.size());
    std::transform(a.begin(), a.end(), b.begin(), result.begin(),
                   [](double x, double y) { return x + y; });
    return result;
}

void Calculator::add(double value) {
    result_ += value;
}

void Calculator::multiply(double value) {
    result_ *= value;
}

void Calculator::reset() {
    result_ = 0.0;
}

double Calculator::get_result() const {
    return result_;
}

double Calculator::divide(double value) {
    if (value == 0.0) {
        throw std::domain_error("Division by zero");
    }
    result_ /= value;
    return result_;
}

double safe_divide(double a, double b) {
    if (b == 0.0) {
        throw std::domain_error("Division by zero");
    }
    return a / b;
}

} // namespace math_ops
EOF
        print_success "Created src/math_ops.cpp"

        # Create pybind11 bindings
        cat > src/bindings.cpp << 'EOF'
// Fix for macOS compilation issues with Python.h
#ifdef __APPLE__
#include <cstdint>
#include <stdint.h>
#endif

#include <pybind11/pybind11.h>
#include <pybind11/stl.h>
#include <pybind11/numpy.h>
#include "math_ops.h"

namespace py = pybind11;

PYBIND11_MODULE(MODULE_NAME, m) {
    m.doc() = "C++ math operations exposed to Python via pybind11";

    // Simple functions
    m.def("add", &math_ops::add, "Add two numbers",
          py::arg("a"), py::arg("b"));

    m.def("multiply", &math_ops::multiply, "Multiply two numbers",
          py::arg("a"), py::arg("b"));

    // Vector function
    m.def("elementwise_add", &math_ops::elementwise_add,
          "Add two vectors element-wise",
          py::arg("a"), py::arg("b"));

    // Function with exception handling
    m.def("safe_divide", &math_ops::safe_divide,
          "Safely divide two numbers (throws on division by zero)",
          py::arg("a"), py::arg("b"));

    // Class binding
    py::class_<math_ops::Calculator>(m, "Calculator")
        .def(py::init<>())
        .def("add", &math_ops::Calculator::add, "Add to result")
        .def("multiply", &math_ops::Calculator::multiply, "Multiply result")
        .def("reset", &math_ops::Calculator::reset, "Reset result to 0")
        .def("divide", &math_ops::Calculator::divide,
             "Divide result (throws on division by zero)")
        .def_property_readonly("result", &math_ops::Calculator::get_result,
                               "Get current result");

    // Module-level attributes
    m.attr("__version__") = "0.1.0";
}
EOF
        # Replace module name placeholder
        if [[ -f src/bindings.cpp ]]; then
            sed -i "s/MODULE_NAME/${PROJECT_NAME//-/_}/g" src/bindings.cpp
            print_success "Created src/bindings.cpp"
        fi

        # Create setup.py
        cat > setup.py << EOF
from setuptools import setup, Extension
from pybind11.setup_helpers import Pybind11Extension, build_ext

ext_modules = [
    Pybind11Extension(
        "${PROJECT_NAME//-/_}",
        ["src/bindings.cpp", "src/math_ops.cpp"],
        include_dirs=["src"],
        cxx_std=${CPP_STANDARD},
    ),
]

setup(
    name="${PROJECT_NAME}",
    version="0.1.0",
    author="Your Name",
    author_email="your.email@example.com",
    description="C++ extension module with pybind11",
    ext_modules=ext_modules,
    cmdclass={"build_ext": build_ext},
    zip_safe=False,
    python_requires=">=3.7",
)
EOF
        print_success "Created setup.py"

        # Create Python example
        cat > python/example.py << EOF
#!/usr/bin/env python3
"""Example usage of the C++ extension module."""

import sys
import os

# Add build directory to path for development
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'build'))

import ${PROJECT_NAME//-/_} as cpp_module

def main():
    print(f"Module version: {cpp_module.__version__}")
    print()

    # Simple operations
    a, b = 10.5, 20.3
    print(f"add({a}, {b}) = {cpp_module.add(a, b)}")
    print(f"multiply({a}, {b}) = {cpp_module.multiply(a, b)}")
    print()

    # Vector operations
    vec1 = [1.0, 2.0, 3.0]
    vec2 = [4.0, 5.0, 6.0]
    result = cpp_module.elementwise_add(vec1, vec2)
    print(f"elementwise_add({vec1}, {vec2}) = {result}")
    print()

    # Using the Calculator class
    calc = cpp_module.Calculator()
    print("Calculator demo:")
    calc.add(10)
    print(f"  After add(10): {calc.result}")
    calc.multiply(3)
    print(f"  After multiply(3): {calc.result}")
    calc.divide(2)
    print(f"  After divide(2): {calc.result}")
    calc.reset()
    print(f"  After reset(): {calc.result}")
    print()

    # Exception handling
    try:
        result = cpp_module.safe_divide(10, 0)
    except Exception as e:
        print(f"Caught exception: {e}")

    # Successful division
    result = cpp_module.safe_divide(10, 2)
    print(f"safe_divide(10, 2) = {result}")

if __name__ == "__main__":
    main()
EOF
        print_success "Created python/example.py"

        # Create C++ test
        cat > tests/test_cpp.cpp << 'EOF'
#include <gtest/gtest.h>
#include "math_ops.h"

TEST(MathOpsTest, AddFunction) {
    EXPECT_DOUBLE_EQ(math_ops::add(2.0, 3.0), 5.0);
    EXPECT_DOUBLE_EQ(math_ops::add(-1.0, 1.0), 0.0);
}

TEST(MathOpsTest, MultiplyFunction) {
    EXPECT_DOUBLE_EQ(math_ops::multiply(2.0, 3.0), 6.0);
    EXPECT_DOUBLE_EQ(math_ops::multiply(-2.0, 3.0), -6.0);
}

TEST(MathOpsTest, VectorAdd) {
    std::vector<double> a = {1.0, 2.0, 3.0};
    std::vector<double> b = {4.0, 5.0, 6.0};
    std::vector<double> expected = {5.0, 7.0, 9.0};

    auto result = math_ops::elementwise_add(a, b);

    ASSERT_EQ(result.size(), expected.size());
    for (size_t i = 0; i < result.size(); ++i) {
        EXPECT_DOUBLE_EQ(result[i], expected[i]);
    }
}

TEST(MathOpsTest, VectorAddSizeMismatch) {
    std::vector<double> a = {1.0, 2.0};
    std::vector<double> b = {4.0, 5.0, 6.0};

    EXPECT_THROW(math_ops::elementwise_add(a, b), std::runtime_error);
}

TEST(CalculatorTest, BasicOperations) {
    math_ops::Calculator calc;

    EXPECT_DOUBLE_EQ(calc.get_result(), 0.0);

    calc.add(10.0);
    EXPECT_DOUBLE_EQ(calc.get_result(), 10.0);

    calc.multiply(3.0);
    EXPECT_DOUBLE_EQ(calc.get_result(), 30.0);

    calc.divide(2.0);
    EXPECT_DOUBLE_EQ(calc.get_result(), 15.0);

    calc.reset();
    EXPECT_DOUBLE_EQ(calc.get_result(), 0.0);
}

TEST(CalculatorTest, DivisionByZero) {
    math_ops::Calculator calc;
    calc.add(10.0);

    EXPECT_THROW(calc.divide(0.0), std::domain_error);
}

TEST(SafeDivideTest, NormalDivision) {
    EXPECT_DOUBLE_EQ(math_ops::safe_divide(10.0, 2.0), 5.0);
}

TEST(SafeDivideTest, DivisionByZero) {
    EXPECT_THROW(math_ops::safe_divide(10.0, 0.0), std::domain_error);
}

int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
EOF
        print_success "Created tests/test_cpp.cpp"

        # Create Python test
        cat > tests/test_python.py << EOF
#!/usr/bin/env python3
"""Tests for the Python bindings of the C++ module."""

import sys
import os
import pytest

# Add build directory to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..', 'build'))

import ${PROJECT_NAME//-/_} as cpp_module

def test_add():
    assert cpp_module.add(2.0, 3.0) == 5.0
    assert cpp_module.add(-1.0, 1.0) == 0.0
    assert cpp_module.add(0.0, 0.0) == 0.0

def test_multiply():
    assert cpp_module.multiply(2.0, 3.0) == 6.0
    assert cpp_module.multiply(-2.0, 3.0) == -6.0
    assert cpp_module.multiply(0.0, 100.0) == 0.0

def test_elementwise_add():
    vec1 = [1.0, 2.0, 3.0]
    vec2 = [4.0, 5.0, 6.0]
    result = cpp_module.elementwise_add(vec1, vec2)
    assert result == [5.0, 7.0, 9.0]

def test_elementwise_add_size_mismatch():
    vec1 = [1.0, 2.0]
    vec2 = [4.0, 5.0, 6.0]
    with pytest.raises(ValueError):
        cpp_module.elementwise_add(vec1, vec2)

def test_calculator_basic():
    calc = cpp_module.Calculator()
    assert calc.result == 0.0

    calc.add(10.0)
    assert calc.result == 10.0

    calc.multiply(3.0)
    assert calc.result == 30.0

    calc.divide(2.0)
    assert calc.result == 15.0

    calc.reset()
    assert calc.result == 0.0

def test_calculator_division_by_zero():
    calc = cpp_module.Calculator()
    calc.add(10.0)

    with pytest.raises(ValueError):
        calc.divide(0.0)

def test_safe_divide():
    assert cpp_module.safe_divide(10.0, 2.0) == 5.0
    assert cpp_module.safe_divide(15.0, 3.0) == 5.0

    with pytest.raises(ValueError):
        cpp_module.safe_divide(10.0, 0.0)

def test_module_version():
    assert hasattr(cpp_module, '__version__')
    assert isinstance(cpp_module.__version__, str)

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
EOF
        print_success "Created tests/test_python.py"

        # Create requirements.txt with dependencies
        cat > requirements.txt << 'EOF'
pytest>=7.0.0
numpy>=1.20.0
EOF
        print_success "Created requirements.txt with dependencies"

        # Create conanfile.txt for C++ dependencies
        cat > conanfile.txt << 'EOF'
[requires]
pybind11/2.11.1
gtest/1.14.0

[generators]
CMakeDeps
CMakeToolchain

[options]

[imports]
EOF
        print_success "Created conanfile.txt for C++ dependencies"

        # Create local Conan profiles with correct compiler version
        if [[ ! -d ".conan2/profiles" ]]; then
            mkdir -p .conan2/profiles

            # Create release profile
            cat > .conan2/profiles/release << EOF
[settings]
arch=armv8
build_type=Release
compiler=clang
compiler.cppstd=$CPP_STANDARD
compiler.libcxx=libc++
compiler.version=$LLVM_VERSION
os=Macos

[conf]
tools.build:exelinkflags=['-fuse-ld=lld']
tools.build:jobs=10
tools.build:sharedlinkflags=['-fuse-ld=lld']
tools.cmake.cmaketoolchain:extra_variables={'CMAKE_EXPORT_COMPILE_COMMANDS': 'ON'}
tools.cmake.cmaketoolchain:generator=Ninja

[buildenv]
CC=clang
CXX=clang++
LD=lld
CMAKE_EXPORT_COMPILE_COMMANDS=ON
EOF

            # Create debug profile
            cat > .conan2/profiles/debug << EOF
[settings]
arch=armv8
build_type=Debug
compiler=clang
compiler.cppstd=$CPP_STANDARD
compiler.libcxx=libc++
compiler.version=$LLVM_VERSION
os=Macos

[conf]
tools.build:exelinkflags=['-fuse-ld=lld']
tools.build:jobs=10
tools.build:sharedlinkflags=['-fuse-ld=lld']
tools.cmake.cmaketoolchain:extra_variables={'CMAKE_EXPORT_COMPILE_COMMANDS': 'ON'}
tools.cmake.cmaketoolchain:generator=Ninja

[buildenv]
CC=clang
CXX=clang++
LD=lld
CMAKE_EXPORT_COMPILE_COMMANDS=ON
EOF
            print_success "Created local Conan profiles (release and debug)"
        fi

        # Create .nvim.lua for C++/Python hybrid support
        cat > .nvim.lua << 'EOF'
-- Local nvim config for C++/Python hybrid project
local venv_path = vim.fn.getcwd() .. '/.venv'
local venv_bin = venv_path .. '/bin'

-- Set Python host for nvim
vim.g.python3_host_prog = venv_bin .. '/python'

-- Ensure compile_commands.json is found by clangd
if vim.fn.filereadable('build/compile_commands.json') == 1 then
    vim.fn.system('ln -sf build/compile_commands.json .')
end

-- Configure DAP for both C++ and Python
local dap = require('dap')

-- C++ DAP configuration
dap.adapters.lldb = {
    type = 'executable',
    command = '/usr/bin/lldb-dap',
    name = 'lldb'
}

dap.configurations.cpp = {
    {
        name = 'Launch C++ tests',
        type = 'lldb',
        request = 'launch',
        program = function()
            return vim.fn.getcwd() .. '/build/tests/test_cpp'
        end,
        cwd = '${workspaceFolder}',
        stopOnEntry = false,
    },
}

-- Python DAP configuration
dap.adapters.python = {
    type = 'executable',
    command = venv_bin .. '/python',
    args = { '-m', 'debugpy.adapter' },
}

dap.configurations.python = {
    {
        type = 'python',
        request = 'launch',
        name = 'Launch Python tests',
        program = '${workspaceFolder}/tests/test_python.py',
        pythonPath = venv_bin .. '/python',
    },
}

-- Custom keymaps for hybrid project
vim.keymap.set('n', '<leader>bc', ':!cmake --build build<CR>', { desc = 'Build C++ extension' })
vim.keymap.set('n', '<leader>bt', ':!cd build && ctest<CR>', { desc = 'Run C++ tests' })
vim.keymap.set('n', '<leader>bp', ':!pytest tests/<CR>', { desc = 'Run Python tests' })
vim.keymap.set('n', '<leader>be', ':!python python/example.py<CR>', { desc = 'Run example' })
EOF
        print_success "Created .nvim.lua for C++/Python hybrid LSP/DAP configuration"
        ;;
esac

print_success "Project initialized successfully!"